<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>F1 2025 Schedule — Oslo time (fixed)</title>
<style>
/* Layout */
html,body{margin:0;padding:0;height:100%;background:#0d1b2a;color:#fff;font-family:Arial,Helvetica,sans-serif;}
.container{box-sizing:border-box;padding:1vh;max-width:420px;margin:0 auto;overflow:auto;height:100%;}

/* Card */
.race{
  margin:0.6vh 0;
  padding:0.8vh;
  border-radius:8px;
  background:rgba(255,255,255,0.03);
  border:1px solid rgba(255,255,255,0.06);
  box-shadow:0 1px 0 rgba(0,0,0,0.25) inset;
}

/* Title / meta */
.race-title{font-weight:700;font-size:2.2vh;color:#ffffff;margin-bottom:0.35vh;}
.race-meta{font-size:1.4vh;opacity:0.9;margin-bottom:0.6vh;color:#d6e1ea;}

/* Sessions: left name, right time */
.session{
  display:flex;
  justify-content:space-between;
  align-items:center;
  font-size:1.5vh;
  padding:0.18vh 0;
  border-bottom:1px solid rgba(255,255,255,0.04);
  line-height:1.1;
}
.session:last-child{border-bottom:none;}
.session-name{color:#e8eef6;font-weight:600;}
.session-time{color:#cfe3f4;}

/* Past / current */
.past{opacity:0.55;border-color:rgba(100,100,100,0.5);background:rgba(80,80,80,0.03);}
.highlight{border:0.28vh solid #ffeb3b;background:linear-gradient(0deg, rgba(255,250,200,0.03), rgba(255,250,200,0.015));}

/* small footer */
.footer{font-size:1.2vh;text-align:right;margin-top:1vh;opacity:0.8;color:#b9c4ce;}
.error{color:#ff8a80;margin:1vh 0;}
</style>
</head>
<body>
<div class="container" id="schedule">Loading schedule…</div>
<div class="footer" id="updated"></div>

<script>
/* Robust timezone conversion helpers with fallbacks for older Intl implementations.
   - localWallTimeToInstant(localIsoNoOffset, tz) => Date (instant) for that wall time in tz
   - formatInOslo(date) => human readable Oslo time "YYYY-MM-DD HH:MM"
*/

// small helper
function pad(n){ return (n<10?'0':'')+n; }

// Safe function to get parts for a Date in a given IANA timezone.
// Returns object with keys: year, month, day, hour, minute, second
function getDatePartsForZone(dateObj, tz) {
  var opts = { timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false };
  var formatter = new Intl.DateTimeFormat('en-GB', opts);
  if (typeof formatter.formatToParts === 'function') {
    var parts = formatter.formatToParts(dateObj);
    var res = {};
    for (var i=0;i<parts.length;i++){
      var t = parts[i];
      if (t.type) res[t.type] = t.value;
    }
    return { year:parseInt(res.year,10), month:parseInt(res.month,10), day:parseInt(res.day,10), hour:parseInt(res.hour,10), minute:parseInt(res.minute,10), second:parseInt(res.second,10) };
  } else {
    // fallback: parse formatted string like "DD/MM/YYYY, HH:MM:SS"
    var s = formatter.format(dateObj); // e.g. "21/09/2025, 13:30:00"
    var m = s.match(/(\d{1,2})\/(\d{1,2})\/(\d{4}).*?(\d{1,2}):(\d{2}):?(\d{2})?/);
    if (m) {
      return { year:parseInt(m[3],10), month:parseInt(m[2],10), day:parseInt(m[1],10), hour:parseInt(m[4],10), minute:parseInt(m[5],10), second:parseInt(m[6]||'0',10) };
    } else {
      // last-resort: use UTC parts (not ideal)
      return { year:dateObj.getUTCFullYear(), month:dateObj.getUTCMonth()+1, day:dateObj.getUTCDate(), hour:dateObj.getUTCHours(), minute:dateObj.getUTCMinutes(), second:dateObj.getUTCSeconds() };
    }
  }
}

// Convert a local wall-time (like "2025-09-19T13:30:00") in timezone tz to an instant Date.
// Algorithm:
//  - compute approxEpoch = Date.UTC(year,month-1,day,h,m,s)
//  - format approxEpoch in tz to find what wall time it corresponds to
//  - difference (approx - formattedWallUtc) gives offset to convert any wall time in that tz to epoch.
function localWallTimeToInstant(localIsoNoOffset, tz) {
  if (!localIsoNoOffset || !tz) return null;
  var parts = localIsoNoOffset.split(/[:T-]/).map(function(x){return parseInt(x,10);});
  if (parts.length < 3 || isNaN(parts[0])) return null;
  var year = parts[0], month = parts[1], day = parts[2], hour = parts[3]||0, minute = parts[4]||0, second = parts[5]||0;

  // approx epoch if interpreted as UTC
  var approx = Date.UTC(year, month-1, day, hour, minute, second);

  // get what that epoch shows as in the tz
  var formattedParts = getDatePartsForZone(new Date(approx), tz);
  var approxWallMillis = Date.UTC(formattedParts.year, formattedParts.month-1, formattedParts.day, formattedParts.hour, formattedParts.minute, formattedParts.second);

  var diff = approx - approxWallMillis;
  // desired wall UTC from provided wall-time
  var desiredWallUtc = Date.UTC(year, month-1, day, hour, minute, second);
  var epoch = desiredWallUtc - diff;
  return new Date(epoch);
}

// Format instant into Oslo local string "YYYY-MM-DD HH:MM"
function formatInOslo(d) {
  if (!d || isNaN(d.getTime())) return 'TBA';
  // use Intl to get parts, fallback if needed
  var opts = { timeZone: 'Europe/Oslo', year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', hour12:false };
  var formatter = new Intl.DateTimeFormat('en-GB', opts);
  if (typeof formatter.formatToParts === 'function') {
    var parts = formatter.formatToParts(d);
    var map = {};
    for (var i=0;i<parts.length;i++){ if(parts[i].type) map[parts[i].type]=parts[i].value; }
    return map.year + '-' + map.month + '-' + map.day + ' ' + map.hour + ':' + map.minute;
  } else {
    var s = formatter.format(d); // e.g. "21/09/2025, 13:30"
    var m = s.match(/(\d{1,2})\/(\d{1,2})\/(\d{4}).*?(\d{1,2}):(\d{2})/);
    if (m) {
      var day = pad(parseInt(m[1],10));
      var month = pad(parseInt(m[2],10));
      var year = m[3];
      var hour = pad(parseInt(m[4],10));
      var minute = m[5];
      return year + '-' + month + '-' + day + ' ' + hour + ':' + minute;
    }
    // fallback to UTC-ish display (shouldn't happen on modern browsers)
    return d.getUTCFullYear() + '-' + pad(d.getUTCMonth()+1) + '-' + pad(d.getUTCDate()) + ' ' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes());
  }
}

/* ---------- Load and render ---------- */
function loadAndRender(){
  var scheduleDiv = document.getElementById('schedule');
  scheduleDiv.innerHTML = 'Loading schedule…';
  fetch('races.json', {cache:'no-store'}).then(function(resp){
    if(!resp.ok) throw new Error('Failed to fetch races.json: ' + resp.status);
    return resp.json();
  }).then(function(data){
    var now = new Date();
    var past = [], upcoming = [], current = null;

    // Convert sessions to instants and classify
    for (var i=0;i<data.length;i++){
      var r = data[i];
      var instants = [];
      if (!r.sessions || !Array.isArray(r.sessions)) r.sessions = [];
      for (var j=0;j<r.sessions.length;j++){
        var s = r.sessions[j];
        var instant = null;
        if (s.localDateTime && r.timezone) {
          try { instant = localWallTimeToInstant(s.localDateTime, r.timezone); }
          catch(e) { instant = null; }
        }
        // fallback: try Date parse (may be wrong without offset)
        if (!instant && s.localDateTime) {
          var d = new Date(s.localDateTime);
          if (!isNaN(d.getTime())) instant = d;
        }
        instants.push({session:s, instant: instant});
      }

      // find P1 and Race
      var p1i=null, racei=null;
      for (var k=0;k<instants.length;k++){
        var it = instants[k];
        if (it.session && it.session.name === 'P1') p1i = it.instant;
        if (it.session && (it.session.type === 'race-event' || it.session.name === 'Race')) racei = it.instant;
      }

      if (p1i && racei) {
        var raceEndBuffer = new Date(racei.getTime() + 2*60*60*1000);
        if (now >= p1i && now <= raceEndBuffer) current = {race:r, instants:instants};
        else if (now < p1i) upcoming.push({race:r, instants:instants});
        else past.push({race:r, instants:instants});
      } else {
        upcoming.push({race:r, instants:instants});
      }
    }

    // sort upcoming/past by round if available
    upcoming.sort(function(a,b){ return (a.race.round||0) - (b.race.round||0); });
    past.sort(function(a,b){ return (a.race.round||0) - (b.race.round||0); });

    // render DOM
    scheduleDiv.innerHTML = '';
    function renderBlock(obj, cls, isHighlight) {
      var r = obj.race;
      var instants = obj.instants;
      var wrap = document.createElement('div');
      wrap.className = 'race' + (cls ? ' '+cls : '') + (isHighlight ? ' highlight' : '');
      var title = document.createElement('div'); title.className = 'race-title'; title.textContent = r.title;
      var meta = document.createElement('div'); meta.className = 'race-meta'; meta.textContent = r.location + ' • ' + r.track + ' • ' + r.dates;
      wrap.appendChild(title); wrap.appendChild(meta);
      for (var s=0;s<instants.length;s++){
        var item = instants[s];
        var sessionDiv = document.createElement('div');
        sessionDiv.className = 'session';
        var nameSpan = document.createElement('span'); nameSpan.className='session-name';
        nameSpan.textContent = item.session && item.session.name ? item.session.name : 'Session';
        var timeSpan = document.createElement('span'); timeSpan.className='session-time';
        var formatted = 'TBA';
        if (item.instant && !isNaN(item.instant.getTime())) formatted = formatInOslo(item.instant);
        timeSpan.textContent = formatted;
        sessionDiv.appendChild(nameSpan);
        sessionDiv.appendChild(timeSpan);
        wrap.appendChild(sessionDiv);
      }
      scheduleDiv.appendChild(wrap);
    }

    if (current) renderBlock(current, '', true);
    for (var u=0; u<upcoming.length; u++) renderBlock(upcoming[u], '');
    for (var p=0; p<past.length; p++) renderBlock(past[p], 'past');

    // updated timestamp
    var upd = document.getElementById('updated');
    upd.textContent = 'Last checked: ' + new Date().toLocaleString();
  }).catch(function(err){
    var scheduleDiv = document.getElementById('schedule');
    scheduleDiv.innerHTML = '<div class="error">Error loading schedule: ' + (err.message || err) + '</div>';
    console.error(err);
  });
}

// initial
loadAndRender();
// refresh every minute
setInterval(loadAndRender, 60000);
</script>
</body>
</html>
